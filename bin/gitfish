#!/usr/bin/env node
var fs      = require('fs');
var which   = require('which').sync;
var path    = require('path');
var action  = process.argv[2];
var confile = process.argv[3];

// Ensure forever.
var forever;
try {
    forever = which('forever');
} catch (e) {
    forever = path.resolve(__dirname, '..', 'node_modules', '.bin', 'forever');
}
if (!fs.existsSync(forever)) {
    usage(new Error('Forever not found.'));
}

// Default config file, if not specified.
if (typeof confile === 'undefined') {
    confile = path.resolve(process.cwd(), 'config.json');
}

// Config file must exist.
if (!fs.existsSync(confile)) {
    usage(new Error('Config file ('+confile+') wasn\'t found.'));
}

var script = 'gitfish.js';
var args = [process.argv[0], forever, action];
var config = require(confile);
var log = config.log || path.resolve(__dirname, '..', 'gitfish.log');
switch(action) {
    case 'config':
    case 'configure':
        buildConfiguration();
        break;
    case 'run':
        require('../')({ config: confile || 'config.json' });
        break;
    case 'start':
    case 'restart':
        args = startArgs(args);
        args.push(script);
        execForever(args);
        break;
    case 'stop':
    case 'logs':
        args.push(script);
        execForever(args);
        break;
    case 'list':
        execForever(args);
        break;
    default:
        usage();
}

function startArgs(args) {
    return args.concat([
        "--max", "1",
        "--minUptime", "2000",
        "--spinSleepTime", "2000",
        "--plain", "--append",
        "--sourceDir", path.resolve(__dirname),
        "--pidFile", path.resolve(__dirname, '..', 'gitfish.pid'),
        "--outFile", log,
        "--errFile", log,
        "--logFile", log
    ]);
}

function execForever(args) {
    //console.dir(args);
    //console.log(args.join(' '));
    var childProcess = require('child_process');
    childProcess.exec(args.join(' '), function (err, stdout, stderr) {
        if (err) {
            usage(err);
        } else if (stderr) {
            usage(new Error(stderr));
        } else {
            console.log(stdout);
            process.exit(0);
        }
    });
}

// Print usage.
function usage(err) {
    if (err) {
        console.log(err.message);
        //console.log(' ');
    }
    console.log('USAGE: gitfish ACTION [CONFIG_FILE]');
    console.log(' ');
    console.log(' Default CONFIG_FILE is <cwd>/config.json');
    console.log(' ');
    console.log(' Actions:');
    console.log(' - config  :: build gitfish configuration file');
    console.log(' - run     :: start gitfish in current session');
    console.log(' - start   :: starts gitfish daemonized w/ forever');
    console.log(' - restart :: restarts gitfish daemon');
    console.log(' - stop    :: stops gitfish daemon');
    console.log(' - list    :: gitfish daemon information');
    console.log(' ');
    process.exit(1);
}

function buildConfiguration() {
    var c = {};
    var script;

    function getHook(answer) {
        script = answer.trim();
        c[script] = undefined;
    }

    function getHookScript(answer) {
        c[script].script = answer.trim();
    }

    function getHookBranch(answer) {
        c[script].branch = answer.trim();
    }

    var readline = require('readline');
    var async    = require('async');
    var read = readline.createInterface({
      input: process.stdin,
      output: process.stdout
    });

    async.series([
        function port(callback) {
            read.question('Listener port? [8000] ', function (answer) {
                c.port = parseInt((answer || '8000').trim(), 10);
                callback();
            });
        },
        function token(callback) {
            read.question('Security token? [secret] ', function (answer) {
                c.token = (answer || 'secret').trim();
                callback();
            });
        },
        function hook(callback) {
            read.question('Hook endpoint? [script] ', function (answer) {
                script = (answer || 'script').trim();
                if (script.indexOf('/') === 0) {
                    script = script.substring(1);
                }
                c[script] = {};
                callback();
            });
        },
        function hookscript(callback) {
            read.question('Hook script? [PWD/script.js] ', function (answer) {
                c[script].script = (answer || path.resolve(process.cwd(), 'script.js')).trim();
                callback();
            });
        },
        function hookbranch(callback) {
            read.question('Hook branch filter? ', function (answer) {
                if (answer) {
                    c[script].branch = answer.trim();
                }
                callback();
            });
        }
    ], function () {
        read.close();
        var out = path.resolve(process.cwd(), 'config.json');
        fs.writeFile(out, JSON.stringify(c, null, 2), { encoding: 'utf8' }, function (err) {
            if (err) {
                console.trace(err);
                process.exit(1);
            }
            console.log('Savd configuration to %s', out);
            process.exit(0);
        });
    });
}
