#!/usr/bin/env node
var fs      = require('fs');
var which   = require('which').sync;
var path    = require('path');

var script  = 'gitfish.js';
var action  = process.argv[2];
var confile = process.argv[3];

var settings;

switch(action) {

    // gitfish config
    case 'config':
        buildConfiguration();
        break;

    // gitfish run
    case 'run':
        require('../')({ config: ensureConfile(confile) });
        break;

    // gitfish stop|logs
    case 'stop':
    case 'logs':
        settings = setup();
        settings.args.push(script);
        execForever(settings.args);
        break;

    // gitfish status|logs
    case 'status':
    case 'list':
        settings = setup();
        execForever(settings.args);
        break;

    // gitfish start|restart
    case 'start':
    case 'restart':
        ensureConfile(confile);

        settings = setup();
        settings.args = settings.args.concat([
            "--minUptime", "2000",
            "--spinSleepTime", "2000",
            "--plain", "--append",
            "--sourceDir", path.resolve(__dirname),
            "--pidFile", '/tmp/gitfish.pid',
            "--outFile", settings.log,
            "--errFile", settings.log,
            "--logFile", settings.log,
            script
        ]);

        execForever(settings.args);
        break;

    default:
        usage();
}

// TODO: Make more modular. Started as script the grew and grew.

function execForever(args) {
    var childProcess = require('child_process');
    childProcess.exec(args.join(' '), function (err, stdout, stderr) {
        if (err) {
            usage(err);
        } else if (stderr) {
            usage(new Error(stderr));
        } else {
            console.log(stdout);
            process.exit(0);
        }
    });
}

// Print usage.
function usage(err) {
    if (err) {
        console.log(err.message);
        //console.log(' ');
    }
    console.log('USAGE: gitfish ACTION [CONFIG_FILE]');
    console.log(' ');
    console.log(' Default CONFIG_FILE is <cwd>/config.json');
    console.log(' ');
    console.log(' Actions:');
    console.log(' - config  :: build gitfish configuration file');
    console.log(' - run     :: start gitfish in current session');
    console.log(' - start   :: starts gitfish daemonized w/ forever');
    console.log(' - restart :: restarts gitfish daemon');
    console.log(' - stop    :: stops gitfish daemon');
    console.log(' - list    :: gitfish daemon information');
    console.log(' ');
    process.exit(1);
}

function setup(checkConfile) {
    return {
        args:   [process.argv[0], ensureForever(), action],
        config: (checkConfile === true ? require(confile) : {}),
        logs:   (config.log || path.resolve(process.cwd(), 'gitfish.log'))
    };
}

function ensureConfile(cf) {
    // Default config file, if not specified.
    if (typeof cf === 'undefined') {
        cf = path.resolve(process.cwd(), 'config.json');
    }

    // Config file must exist.
    if (!fs.existsSync(cf)) {
        usage(new Error('Config file ('+cf+') wasn\'t found.'));
    }

    return cf;
}

function ensureForever() {
    var forever;
    try {
        forever = which('forever');
    } catch (e) {
        forever = path.resolve(__dirname, '..', 'node_modules', '.bin', 'forever');
    }
    if (!fs.existsSync(forever)) {
        usage(new Error('Forever not found.'));
    }
    return forever;
}

function buildConfiguration() {
    var c = {};
    var script;

    function getHook(answer) {
        script = answer.trim();
        c[script] = undefined;
    }

    function getHookScript(answer) {
        c[script].script = answer.trim();
    }

    function getHookBranch(answer) {
        c[script].branch = answer.trim();
    }

    var readline = require('readline');
    var async    = require('async');
    var read = readline.createInterface({
      input: process.stdin,
      output: process.stdout
    });

    async.series([
        function port(callback) {
            read.question('Listener port? [8000] ', function (answer) {
                c.port = parseInt((answer || '8000').trim(), 10);
                callback();
            });
        },
        function token(callback) {
            read.question('Security token? [secret] ', function (answer) {
                c.token = (answer || 'secret').trim();
                callback();
            });
        },
        function logs(callback) {
            read.question('Log location? [/tmp/gitfish.log] ', function (answer) {
                c.log = (answer || '/tmp/gitfish.log').trim();
                callback();
            });
        },
        function hook(callback) {
            read.question('Hook endpoint? [script] ', function (answer) {
                script = (answer || 'script').trim();
                if (script.indexOf('/') === 0) {
                    script = script.substring(1);
                }
                c[script] = {};
                callback();
            });
        },
        function hookscript(callback) {
            read.question('Hook script? [PWD/script.js] ', function (answer) {
                c[script].script = (answer || path.resolve(process.cwd(), 'script.js')).trim();
                callback();
            });
        },
        function hookbranch(callback) {
            read.question('Hook branch filter? ', function (answer) {
                if (answer) {
                    c[script].branch = answer.trim();
                }
                callback();
            });
        }
    ], function () {
        read.close();
        var out = path.resolve(process.cwd(), 'config.json');
        fs.writeFile(out, JSON.stringify(c, null, 2), { encoding: 'utf8' }, function (err) {
            if (err) {
                console.trace(err);
                process.exit(1);
            }
            console.log('Savd configuration to %s', out);
            process.exit(0);
        });
    });
}
